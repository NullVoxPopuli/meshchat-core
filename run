#!/usr/bin/env ruby
# frozen_string_literal: true

current_dir = File.dirname(__FILE__)
# set load path (similar to how gems require files (relative to lib))

lib = current_dir + '/lib/'
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require current_dir + '/lib/meshchat'

module Debug
  class CLIOutput < Meshchat::Ui::Display::Base
    def start
      puts "\n"
      alert 'Welcome to Spiced Rumby!'
      puts "\n"
      puts "\n"
    end

    def fatal(*args)
      alert(*args)
    end

    def debug(*args)
      warning(*args)
    end

    def error(*args)
      alert(*args)
    end

    # TODO: find a more elegant way to handle color
    def add_line(line)
      puts line
    end

    def info(msg)
      message_parts_for(msg) do |_time, _from, message|
        puts message.colorize(:light_black)
      end
    end

    def message_parts_for(msg)
      return yield(nil, nil, msg) if msg.is_a?(String)

      time = msg[:time].strftime('%H:%M:%S')
      name = msg[:from].to_s
      message = msg[:message]

      yield(time, name, message)
    end

    def warning(msg)
      puts msg.colorize(:yellow) if msg
    end

    def alert(msg)
      puts msg.colorize(:red) if msg
    end

    def success(msg)
      puts msg.colorize(:green)
    end

    def chat(msg)
      message_parts_for(msg) do |time, name, message|
        colored_time = (time.to_s + ' ').colorize(:light_magenta)
        colored_name = (name + ' ').colorize(:cyan)

        print colored_time
        print colored_name
        print message + "\n"
      end
    end

    def whisper(msg)
      message_parts_for(msg) do |time, name, message|
        colored_time = (time.to_s + ' ').colorize(:magenta)
        colored_name = (name + ' ').colorize(:light_black)

        print colored_time
        print colored_name
        print message + "\n"
      end
    end
  end
end

Meshchat.start(
  display: Debug::CLIOutput, # your class implementing `Display::Base`
)
